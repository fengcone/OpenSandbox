# Secure Container Runtime Guide

This guide explains how to use secure container runtimes with OpenSandbox to provide hardware-level isolation for executing untrusted AI-generated code.

## Table of Contents

- [Overview](#overview)
- [User Guide](#user-guide)
- [Administrator Guide](#administrator-guide)
- [Troubleshooting and Best Practices](#troubleshooting-and-best-practices)

---

## Overview

### What are Secure Container Runtimes?

Secure container runtimes provide stronger isolation than the standard runc runtime used by Docker and containerd. They add additional security layers through different mechanisms:

| Runtime | Isolation Mechanism | Startup Overhead | Memory Overhead | Best For |
|---------|---------------------|------------------|-----------------|----------|
| **runc** (default) | Process-level cgroups | ~0ms | Minimal | Trusted workloads, local development |
| **gVisor** | User-space kernel (syscall interception) | ~10-50ms | ~50MB | General workloads with low overhead |
| **Kata (QEMU)** | Full VM with QEMU hypervisor | ~500ms | ~20-50MB | Maximum compatibility and isolation |
| **Kata (Firecracker)** | MicroVM with Firecracker hypervisor | ~125ms | ~5MB | High density, minimal footprint |
| **Kata (CLH)** | Cloud Hypervisor | ~200ms | ~10-20MB | Balanced performance and isolation |

### Why Use Secure Runtimes?

OpenSandbox is designed to execute untrusted code generated by AI models (Claude, GPT-4, Gemini, etc.). Secure runtimes provide:

1. **Container Escape Protection**: Prevents malicious code from breaking out of the container
2. **Kernel-Level Isolation**: Each sandbox gets its own kernel context
3. **Multi-Tenant Safety**: Different users' sandboxes are strongly isolated
4. **Compliance**: Meets security requirements for regulated industries

### Supported Runtime Types

OpenSandbox supports the following secure runtime types:

- `"gvisor"` - Google gVisor with runsc
- `"kata"` - Kata Containers with QEMU hypervisor (default)
- `"firecracker"` - Kata Containers with Firecracker hypervisor
- Custom runtimes configured by administrators

---

## User Guide

This section is for AI application developers who want to use secure containers when creating sandboxes.

### Kubernetes Mode (Currently Available)

In Kubernetes mode, secure runtimes are specified through `RuntimeClass` on the Pool CRD. The sandbox server then validates that your request matches the pool's configured runtime.

#### Creating a Sandbox with gVisor Runtime

**Step 1: Administrator creates a Pool with gVisor RuntimeClass**

```yaml
# gvisor-pool.yaml
apiVersion: sandbox.opensandbox.io/v1alpha1
kind: Pool
metadata:
  name: gvisor-pool
spec:
  template:
    spec:
      runtimeClassName: gvisor  # Use gVisor runtime
      containers:
        - name: sandbox-container
          image: python:3.11
          command: ["sleep", "3600"]
  capacitySpec:
    bufferMax: 10
    bufferMin: 2
    poolMax: 20
    poolMin: 5
```

Apply the Pool:

```bash
kubectl apply -f gvisor-pool.yaml
```

**Step 2: Create a BatchSandbox using the Pool**

```yaml
# sandbox.yaml
apiVersion: sandbox.opensandbox.io/v1alpha1
kind: BatchSandbox
metadata:
  name: my-secure-sandbox
spec:
  replicas: 1
  poolRef: gvisor-pool  # Use the gVisor pool
```

```bash
kubectl apply -f sandbox.yaml
```

The resulting Pod will run with gVisor runtime, providing syscall-level isolation.

#### Creating a Sandbox with Kata Runtime

The process is identical - just use a Pool configured with the Kata RuntimeClass:

```yaml
apiVersion: sandbox.opensandbox.io/v1alpha1
kind: Pool
metadata:
  name: kata-pool
spec:
  template:
    spec:
      runtimeClassName: kata-qemu  # Use Kata with QEMU
      containers:
        - name: sandbox-container
          image: python:3.11
  capacitySpec:
    bufferMax: 5
    bufferMin: 1
    poolMax: 10
    poolMin: 2
```

### SDK Usage (Planned)

Future SDK releases will support a `secure_runtime` parameter for deployment-agnostic code:

```python
# Python SDK (Planned)
from opensandbox import Sandbox

sandbox = await Sandbox.create(
    image="python:3.11",
    entrypoint=["python", "-c", "print('hello')"],
    secure_runtime="gvisor",  # Specify secure runtime
    # The server maps this to the appropriate RuntimeClass
)
```

```kotlin
// Kotlin SDK (Planned)
val sandbox = Sandbox.create {
    image = "python:3.11"
    entrypoint = listOf("python", "-c", "print('hello')")
    secureRuntime = "gvisor"
}
```

```typescript
// TypeScript SDK (Planned)
const sandbox = await Sandbox.create({
    image: 'python:3.11',
    entrypoint: ['python', '-c', "print('hello')"],
    secureRuntime: 'gvisor',
});
```

**Note**: Until SDK support is implemented, use the Kubernetes RuntimeClass method described above.

### Runtime Selection Guidelines

Choose your runtime based on your security and performance requirements:

| Use Case | Recommended Runtime | Reasoning |
|----------|---------------------|-----------|
| Development/Testing | runc (default) | Fastest startup, lowest overhead |
| Production AI Code Execution | gVisor | Good balance of security and performance |
| High-Security Requirements | Kata (QEMU) | Maximum isolation, full compatibility |
| High-Density Multi-Tenant | Kata (Firecracker) | Minimal memory overhead per sandbox |
| Untrusted Network Code | gVisor or Kata | Syscall filtering prevents network attacks |

---

## Administrator Guide

This section is for platform operators and SREs who need to install and configure secure container runtimes.

### Prerequisites

Secure runtimes must be installed and configured on your infrastructure before OpenSandbox can use them. OpenSandbox does not install runtimes automatically.

### Kubernetes Mode - gVisor Setup

#### Step 1: Install gVisor runsc on All Nodes

Download and install the gVisor runsc binary:

```bash
# Ubuntu/Debian
curl -fsSL https://gvisor.dev/archive.key | sudo gpg --dearmor -o /usr/share/keyrings/gvisor-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/gvisor-archive-keyring.gpg] https://storage.googleapis.com/gvisor/releases release main" | \
  sudo tee /etc/apt/sources.list.d/gvisor.list
sudo apt-get update && sudo apt-get install -y runsc

# Verify installation
runsc --version
```

#### Step 2: Configure containerd

Add gVisor runtime configuration to `/etc/containerd/config.toml`:

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]
  runtime_type = "io.containerd.runsc.v1"
  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc.options]
    TypeUrl = "io.containerd.runsc.v1.options"
    ConfigPath = "/etc/containerd/runsc.toml"
```

Create the runsc configuration file `/etc/containerd/runsc.toml`:

```toml
[runsc]
  platform = "ptrace"  # or "systrap" for better performance
```

Restart containerd:

```bash
sudo systemctl restart containerd
```

#### Step 3: Create RuntimeClass CRD

Create the RuntimeClass resource in Kubernetes:

```yaml
# gvisor-runtimeclass.yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
scheduling:
  nodeSelector:
    kubernetes.io/arch: amd64
```

```bash
kubectl apply -f gvisor-runtimeclass.yaml
```

#### Step 4: Verify Installation

Test that gVisor works by creating a simple Pod:

```bash
kubectl run test-gvisor --restart=Never --image=hello-world --runtime-class=gvisor
kubectl logs test-gvisor
kubectl delete pod test-gvisor
```

### Kubernetes Mode - Kata Containers Setup

#### Step 1: Install Kata Containers

Follow the [official Kata Containers installation guide](https://katacontainers.io/docs/) for your distribution.

Quick installation for Ubuntu:

```bash
bash -c "$(curl -fsSL https://raw.githubusercontent.com/kata-containers/kata-containers/main/utils/kata-manager.sh) install-kata"
```

#### Step 2: Configure containerd for Kata

Add to `/etc/containerd/config.toml`:

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata-qemu]
  runtime_type = "io.containerd.kata-qemu.v2"

[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata-clh]
  runtime_type = "io.containerd.kata-clh.v2"

[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata-fc]
  runtime_type = "io.containerd.kata-fc.v2"
```

Restart containerd:

```bash
sudo systemctl restart containerd
```

#### Step 3: Create RuntimeClass CRDs

```yaml
# kata-runtimeclasses.yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata-qemu
handler: kata-qemu

---
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata-clh
handler: kata-clh

---
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata-fc
handler: kata-fc
```

```bash
kubectl apply -f kata-runtimeclasses.yaml
```

### Creating Pools for Different Runtimes

Create separate Pools for each runtime type you want to support:

```yaml
# gvisor-pool.yaml
apiVersion: sandbox.opensandbox.io/v1alpha1
kind: Pool
metadata:
  name: gvisor-pool
  labels:
    runtime: gvisor  # Label for identification
spec:
  template:
    spec:
      runtimeClassName: gvisor
      containers:
        - name: sandbox-container
          image: opensandbox/code-interpreter:v1.0.1
  capacitySpec:
    bufferMax: 10
    bufferMin: 2
    poolMax: 20
    poolMin: 5

---
# kata-pool.yaml
apiVersion: sandbox.opensandbox.io/v1alpha1
kind: Pool
metadata:
  name: kata-pool
  labels:
    runtime: kata
spec:
  template:
    spec:
      runtimeClassName: kata-qemu
      containers:
        - name: sandbox-container
          image: opensandbox/code-interpreter:v1.0.1
  capacitySpec:
    bufferMax: 5
    bufferMin: 1
    poolMax: 10
    poolMin: 2
```

### Docker Mode Setup (Planned)

Docker mode support is planned for future releases. Setup will involve:

1. Installing the runtime (runsc, kata-runtime)
2. Configuring Docker daemon with runtime definitions
3. Server configuration mapping runtime types to Docker runtime names

### Custom Runtime Configuration

To add a custom secure runtime:

1. Install and configure the runtime on all nodes
2. Create a RuntimeClass CRD for Kubernetes mode
3. Create a Pool using that RuntimeClass
4. Document the runtime type for users

---

## Troubleshooting and Best Practices

### Common Issues

#### 1. RuntimeClass Not Found

**Error**: `RuntimeClass "gvisor" not found`

**Solution**: Ensure the RuntimeClass CRD is created:

```bash
kubectl get runtimeclass
```

If missing, apply the RuntimeClass YAML as shown in the Administrator Guide.

#### 2. Pool Runtime Mismatch

**Error**: `Requested secure runtime 'gvisor' conflicts with pool's runtimeClass='kata-qemu'`

**Solution**: Either:
- Use a Pool that matches your requested runtime
- Omit the `secure_runtime` parameter to accept the pool's default runtime
- Request a new Pool with the correct runtime from your administrator

#### 3. Syscall Compatibility Issues

**Error**: Container exits with code 1, no logs

**Cause**: gVisor doesn't implement all syscalls. Some applications may not be compatible.

**Solution**: Check the [gVisor compatibility guide](https://gvisor.dev/docs/user_guide/compatibility/). Try using Kata (QEMU) which has better compatibility.

#### 4. Pod Stuck in ContainerCreating

**Cause**: RuntimeClass handler not configured on the node.

**Solution**: Verify containerd configuration and restart:

```bash
# On the node
sudo systemctl status containerd
# Check config
sudo containerd config dump
# Restart if needed
sudo systemctl restart containerd
```

### Performance Considerations

#### Startup Time Comparison

| Runtime | Cold Start | Warm Start (from Pool) |
|---------|-----------|------------------------|
| runc | ~500ms | ~50ms |
| gVisor | ~550ms | ~100ms |
| Kata (QEMU) | ~1000ms | ~200ms |
| Kata (Firecracker) | ~625ms | ~125ms |

**Recommendation**: Always use Pools for production workloads to avoid cold start penalties.

#### Memory per Sandbox

| Runtime | Base Memory | Per Sandbox Overhead |
|---------|-------------|----------------------|
| runc | ~0MB | ~5MB |
| gVisor | ~20MB | ~50MB |
| Kata (QEMU) | ~100MB | ~20-50MB |
| Kata (Firecracker) | ~50MB | ~5MB |

**Recommendation**: For high-density deployments, consider Kata with Firecracker or gVisor.

### Compatibility Matrix

| Feature | runc | gVisor | Kata (QEMU) | Kata (CLH) | Kata (FC) |
|---------|------|--------|-------------|------------|-----------|
| Syscall Compatibility | Full | Partial | Full | Full | Limited |
| GPU Support | Yes | No | Yes | Yes | No |
| IPv6 | Yes | Yes | Yes | Yes | Yes |
| Privileged Mode | Yes | No | Yes | Yes | No |
| Docker Volume | Yes | Yes | Yes | Yes | Yes |
| Systemd | Yes | No | Yes | Yes | No |

### Production Best Practices

1. **Always Use Pools**: Pre-warmed sandboxes eliminate startup overhead
2. **Create Runtime-Specific Pools**: Separate pools for each runtime type
3. **Monitor Pool Capacity**: Set appropriate buffer sizes to handle spikes
4. **Label Pools by Runtime**: Use labels like `runtime: gvisor` for easy identification
5. **Test Compatibility**: Validate your workloads with the chosen runtime before production
6. **Have Fallback Pools**: Maintain runc pools for workloads incompatible with secure runtimes

### Security Recommendations

1. **Default to gVisor**: Provides good security with acceptable performance for most workloads
2. **Use Kata for Untrusted Code**: Maximum isolation for completely unknown code
3. **Regular Updates**: Keep runtimes updated for security patches
4. **Network Policies**: Combine with network egress controls
5. **Resource Limits**: Always set CPU and memory limits on sandboxes

### Getting Help

- **Documentation**: [OpenSandbox GitHub](https://github.com/alibaba/OpenSandbox)
- **Issues**: Report bugs via [GitHub Issues](https://github.com/alibaba/OpenSandbox/issues)
- **OSEPs**: See [OSEP-0004](../oseps/0004-secure-container-runtime.md) for complete design details
